<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Documentation</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css"
    />
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Fredericka+the+Great&display=swap");
      .ol li {
        list-style: none;
        text-align: left;
        padding: 10px;
      }
      .hovr li:hover {
        border: 1px solid rgba(0, 0, 0, 0.263);
        background-color: rgba(0, 0, 0, 0.077);
      }
      .wborders li {
        border: 1px solid rgba(0, 0, 0, 0.1);

      }
      #arrow {
        transition: all 1s;
      }
      .ol li::first-letter {
        font-size: 20px;
        font-weight: bolder;
        font-family: "Fredericka the Great";
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        font-family: "Fredericka the Great";
      }
      @media only screen and (max-width: 767px) {
        #heading {
          font-size: 30px;
        }
      }
      @media screen and (max-width:991px){
        #arrow {
          transform: rotateZ(90deg);
        }
      }
      sb {
        font-weight: bolder;
        font-family: "Fredericka the Great";
      }
      /* .fx {
          position: fixed;
          padding: 0;
      } */
/* 
      @media only screen and (max-width: 776px) {

      } */
    </style>
  </head>
  <body class="container" style="padding: 10px">
    <header id="cont">
      <h1 id="heading">CWShell v2.0 Documentation</h1>
      <small>The Best and (possibly only!) documentation of CWShell</small>
    <hr />
    </header>

    <div class="row">
      <div class="col" id="column1">
        <!-- <h2></h2> -->
        <ul class="ol hovr wborders fx" id="contents">
          <h2>Contents</h2>
        </ul>
      </div>

      <div class="col-md-9 p-5" id="content">
        Hello and welcome to CWShellv2.0 Documentation. See the contents to browse for tutorials.
        <br>
          <span class="material-symbols-outlined" style="font-size: 50px;" id="arrow">
            subdirectory_arrow_left
          </span>
      </div>
    </div>

    <script>
      const Tutorials = {
        add(heading_name, content) {
          if (content.trim().length === 0) {
              content = "<b>Please stand by, the documentation is being written</b>"
          }
          this[heading_name] = content
        },

      };
      
      Tutorials.add("Getting the basics", `
      Welcome to CWShell's documentation's first chapter where you will learn how to use CWShell like a beginner and then how to use 
      it like a pro. 
      <hr/>
      <h3>Starting the application</h3>
      <hr/>
      For Unix-Based-OS users, the file you will download will be a Unix Executable itself so you just need to 
      click on it or open it in the terminal and all will be well.
      <br>
      <br>
      For DOS and Windows users, you will get an <code>.exe</code> file that you can open on its on or can run it from
      CMD/PowerShell. 
      <br>
      <br>
      If you're using a custom OS or are keen to edit the code, you'll have to compile the source yourself. Download <a href="https://www.python.org/">Python</a>
      and then download the CWShell Source. In the <code>src</code> directory you will find a <code>requirments.txt</code>, download all those modules 
      and then run the python file. If you want to compile the source into an application we recommend using pyinstaller: <code>pyinstaller --onefile app.py</code>
      <hr/>
      <h3>Basic Commands</h3>
      <hr/>
      <!-- <ul class="ol">

      <li>-->
        <code>info:</code>
        <br>
        <sb>Usage:</sb> The info command basically returns the computer's information depending on what you asked for.
        For example a user want the IPV4 address of his machine so that he can start a server, how would he find the address?
        One solution is to go to the terminal and type <code>"ipconfig"</code>, <code>"ifconfig"</code> or <code>"hostname"</code>. 
        Another way is to go to the CWShell application and type info -i or info --ipv4.
        <br/>
        <sb>Arguments:</sb>
        <br/>
        <code>-i (--ipv4)</code>: As you might have guessed, this returns the ipv4 address of the machine. If you don't
        know about ipv4 address we suggest you look into them before continuing.
        <br/>
        <code>-n (--name)</code>: This returns the name of the machine, meaning the name using which the internet recognises you.
        <hr>
        <!--</li>-->

      <!--<li>-->
        <code>exit:</code>
        <br>
        <sb>Usage:</sb> Every single person who has been introduced to the linux shell would know what this command it. Basically
        it exits the application without another word. Let us see its arguments
        <sb>Arguments:</sb>
        <br/>
        <code>-f (--force)</code>: Using this parameter you can forcefully exit the application and delete the process. Syntax is <code>exit -f</code> or <code>exit --force</code>.
        <br>
        <code>-r (--reload)</code>: Using this parameter is not really recommended because it it currently not so fast. The reload parameter exits the application and starts it again
        such that everything that was done in the previous session is just regarded as a bad dream. Unfortunatly while trying to restart the application, it might duplicate processes 
        making your computer slow. This problem is still under removal. Syntax is <code>exit -r</code> or <code>exit --reload</code>.
        <hr>
        <small>
          <sb>Please note that typing <code>-letter</code> is equivilant to typing <code>--command</code>, meaning that typing <code>info -n</code> is equivalant to typing <code>info --name</code> 
            they are the same parameters only made longer for readibility though it might be important to note that long names i.e <code>--command</code> might be
             a few miliseconds 
            slower than small names i.e <code>-letter</code> because CWShell has to search deep in the command enviornment to find the long parameter names.
          <sb>
        </small>

        <!--</li>-->
      <!--</ul>-->
      <h3>Congratulations! You can now start the CWShell application and can extract info/exit application. In the next chapter we will discuss some of the variables CWShell offers!<h3>
      `)
      
      Tutorials.add("Special Variables", `Welcome to lesson number two! In this chapter we will discuss some of the variables CWShell offers by default, 
      as said in the end of the last lesson.
      <hr>
      <h3>The Rules for variable names</h3>
      <hr>
      Like BASH, SHELLScript <small><b>(and PHP, if you don't mind!)</b></small>, CWShell also uses the dollar sign (i.e “$“) to identify and
      signify variables. An important point to be noted is that when refrencing variable (meaning when addressing them in commands), 
      please consider case sensitivty.
      <hr>
      <h4>The <code>$OUTPUT</code> Variable</h4>
      This is one of two global variables provided by CWShell. The two global variables are automatically set by CWShell when commands 
      are executed. The $OUTPUT (intial value is 0 or None) stores the output of the last command that was called. For instance
      if a user executes <code>info --ip</code>, the return value (i.e the ipv4 address) will be stored in the $OUTPUT variable. 
      Now if the user executes <code>server -a $OUTPUT 5060</code> (<small>will be discussed in other chapters</small>), the 
      CWShell interpreter will replace the <code>$OUTPUT</code> with it's respective value! See they are really handy so that the 
      user doesn't have to type in everything every time he/she starts a server or connects to it!
      <br>
      <h4>The <code>$LAST_COMMAND</code> Variable</h4>
      This variable is absolutly what it sounds like, it contains the last command that was executed. To use this variable,
      just type in <code>$LAST_COMMAND</code> in the CWShell prompt and press enter to execute the last command again.
      <hr>
      <small>
        <sb>
        When you first start a fresh session of CWShell, this variable doesn't exist because you haven't executed any command yet so if you type in 
      $LAST_COMMAND, you will only be greeted by a <code>KeyError</code> or <code>ValueError</code>.
      </sb>

      </small>
      <hr>
      <small>
        <sb>It is worth noting that CWShells global variables are quite relatable to PHP's Super Globals. Another 
          point to be noted is that CWShells variables are not actually like the variables in programming as they
          are just properties of a dictionary (i.e <code>dict()</code>) not sections of the RAM.
        </sb>

      </small>
      <hr>
      <h4>Creating your own variables.</h4>
      <hr>
      To create your own variables, you have to use the similar-to-bash <code>set command</code>. 
      Let's take a quick over veiw of the syntax:
      <code>set [variable_name] [value] </code>.
      If you have dealt with BASH and Shell before, you can skip this section because the command works in the exact same way. If you haven't
      then this is how it works:
      first you type in the name of the variable (that should begin with a $sign) then you have to type it's value. Now you can type that 
      variable any where and get the required output.
      <hr>
      <small>
        <sb>
          Quick example: <br>
          <code>
              🐚 info -i (will return the ip address if you remeber)
              <br/>
              🐚 set $NAME $OUTPUT
          </code>
          <br>
          You can print the output by using <code>exec_from --print [variable_name]<code>
        </sb>
        
      </small>
      `)
      Tutorials.add("Starting a server", "")
      Tutorials.add("Connecting to a server", "")
      Tutorials.add("About execution modes", "")
      Tutorials.add("...", "<h3>Working on it!</h3>")
      // Adding the tutorials to the HTML Markup via DOM
      const element = document.getElementById("contents");
      const content_container = document.getElementById("content");
      for (prop in Tutorials) {
        if (prop != "add") {
          const EL = document.createElement("li");
          EL.innerText = prop;
          const CValue = Tutorials[prop]
          EL.addEventListener("click", (e) => {
            content_container.innerHTML = CValue
            console.log("Changed")
            // console.log(Tutorials[prop])
          });
          element.appendChild(EL);
        }
      }
    </script>
  </body>
</html>
